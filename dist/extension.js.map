{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://wren-potetre2d-language-provider/./src/wrenalyzer-ts/token.ts","webpack://wren-potetre2d-language-provider/./src/wrenmanager.ts","webpack://wren-potetre2d-language-provider/./src/extension.ts","webpack://wren-potetre2d-language-provider/./src/corewren.ts","webpack://wren-potetre2d-language-provider/external commonjs \"vscode\"","webpack://wren-potetre2d-language-provider/./src/wrenalyzer-ts/lexer.ts","webpack://wren-potetre2d-language-provider/./src/wrenalyzer-ts/parser.ts","webpack://wren-potetre2d-language-provider/./src/wrenalyzer-ts/chars.ts","webpack://wren-potetre2d-language-provider/external node-commonjs \"fs\"","webpack://wren-potetre2d-language-provider/./src/wrenalyzer-ts/sourcefile.ts","webpack://wren-potetre2d-language-provider/external node-commonjs \"path\"","webpack://wren-potetre2d-language-provider/webpack/bootstrap","webpack://wren-potetre2d-language-provider/webpack/startup"],"sourcesContent":["import SourceFile from './sourcefile';\n\nclass Token {\n  // Punctuators.\n  static leftParen = \"leftParen\";\n  static rightParen = \"rightParen\";\n  static leftBracket = \"leftBracket\";\n  static rightBracket = \"rightBracket\";\n  static leftBrace = \"leftBrace\";\n  static rightBrace = \"rightBrace\";\n  static colon = \"colon\";\n  static dot = \"dot\";\n  static dotDot = \"dotDot\";\n  static dotDotDot = \"dotDotDot\";\n  static comma = \"comma\";\n  static star = \"star\";\n  static slash = \"slash\";\n  static percent = \"percent\";\n  static plus = \"plus\";\n  static minus = \"minus\";\n  static pipe = \"pipe\";\n  static pipePipe = \"pipePipe\";\n  static caret = \"caret\";\n  static amp = \"amp\";\n  static ampAmp = \"ampAmp\";\n  static question = \"question\";\n  static bang = \"bang\";\n  static tilde = \"tilde\";\n  static equal = \"equal\";\n  static less = \"less\";\n  static lessEqual = \"lessEqual\";\n  static lessLess = \"lessLess\";\n  static greater = \"greater\";\n  static greaterEqual = \"greaterEqual\";\n  static greaterGreater = \"greaterGreater\";\n  static equalEqual = \"equalEqual\";\n  static bangEqual = \"bangEqual\";\n\n  // Keywords.\n  static breakKeyword = \"break\";\n  static classKeyword = \"class\";\n  static constructKeyword = \"construct\";\n  static elseKeyword = \"else\";\n  static falseKeyword = \"false\";\n  static forKeyword = \"for\";\n  static foreignKeyword = \"foreign\";\n  static ifKeyword = \"if\";\n  static importKeyword = \"import\";\n  static inKeyword = \"in\";\n  static isKeyword = \"is\";\n  static nullKeyword = \"null\";\n  static returnKeyword = \"return\";\n  static staticKeyword = \"static\";\n  static superKeyword = \"super\";\n  static thisKeyword = \"this\";\n  static trueKeyword = \"true\";\n  static varKeyword = \"var\";\n  static whileKeyword = \"while\";\n\n  static field = \"field\";\n  static staticField = \"staticField\";\n  static tname = \"name\";\n  static number = \"number\";\n  static string = \"string\";\n  static interpolation = \"interpolation\";\n  static line = \"line\";\n  static error = \"error\";\n  static eof = \"eof\";\n\n  source: SourceFile;\n  type?: string | undefined;\n  start: number;\n  length: number;\n\n  constructor(source: SourceFile, type: string, start: number, length: number) {\n    this.source = source;\n    this.type = type;\n    this.start = start;\n    this.length = length;\n  }\n\n  // The source file this token was parsed from.\n  get text(): string { return this.source.substring(this.start, this.length); }\n\n  // The 1-based line number that the token starts on.\n  get lineStart(): number { return this.source.lineAt(this.start); }\n  get lineEnd(): number { return this.source.lineAt(this.start + this.length); }\n\n  // The 1-based column number that the token starts on.\n  get columnStart(): number { return this.source.columnAt(this.start); }\n  get columnEnd(): number { return this.source.columnAt(this.start + this.length); }\n\n  public toString(): string { return this.text; }\n}\n\nexport default Token;","'use strict';\nimport * as vscode from 'vscode';\n\nimport Lexer from './wrenalyzer-ts/lexer';\nimport Parser, { Module } from './wrenalyzer-ts/parser';\nimport Token from './wrenalyzer-ts/token';\nimport SourceFile from './wrenalyzer-ts/sourcefile';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { coreModules } from './corewren';\n\nclass WrenManager {\n  trees: Map<string, Module | null> = new Map(); // the full ast trees for each file\n  variables: Map<string, vscode.CompletionItem[]> = new Map(); // all the variables for a file\n  searchPaths: Array<string> = []; // additional paths to search if current dir doesn't find a script\n  pending: Set<string> = new Set(); // filenames that have not yet resolved\n\n  completions: Array<vscode.CompletionItem> = []; // list of all completions globally. TODO: split up per file?\n  staticCompletions: Map<string, Array<vscode.CompletionItem>> = new Map(); // static method completions so we can include only the proper ones\n  signatures: [string, vscode.SignatureInformation][] = []; // [function name, [signatures]] globally, non unique function names\n  staticSignatures: Map<string, [string, vscode.SignatureInformation][]> = new Map(); // class -> [function name, [signatures]] globally, non unique function names\n\n  constructor() {\n    // grab the string from corewren.ts to get all the core classes\n    const sourceFile = new SourceFile(\"core\", coreModules);\n    this.parseFile(sourceFile);\n  }\n\n  // add a relative path, useful for global scripts that might not be in the current dir\n  addPathToSearch(p: string): void {\n    this.searchPaths.push(p);\n  }\n\n  // blank out everything and rebuild all generated data\n  updateCompletionItems(): void {\n    console.info(\"Regenerating completion items\");\n\n    this.completions = [];\n    this.staticCompletions = new Map();\n    this.signatures = [];\n    this.staticSignatures = new Map();\n    this.variables = new Map();\n\n    const methodSet: Set<string> = new Set(); // seen method names to prevent dupe completions\n    const classSet: Set<string> = new Set(); // seen class names to prevent dupe completions\n\n    // for each ast, go through and grab everything we want to complete\n    for (let e of this.trees.entries()) {\n      const path: string = e[0];\n      const module: any = e[1];\n\n      const classVars: vscode.CompletionItem[] = []; // array of variables for this file\n      this.variables.set(path, classVars);\n      const uniqVars: Set<string> = new Set(); // per-file, prevent duplicate variable names\n\n      // for each class in the file, go through and grab everything\n      module.statements.filter((o: any) => o.type === 'ClassStmt')\n        .forEach((c: any) => {\n          const staticMethodSet: Set<string> = new Set(); // seen static method names to prevent dupe completion\n\n          // if this is a new class, setup the completion for it\n          if (!classSet.has(c.name.text)) {\n            const item = new vscode.CompletionItem(c.name.text, vscode.CompletionItemKind.Class);\n            item.detail = vscode.workspace.asRelativePath(c.name.source.path);\n            this.completions.push(item);\n            classSet.add(c.name.text);\n          }\n\n          // for every method, build up the method completion and variables inside\n          for (let m of c.methods) {\n            let prefix = '';\n            if (m.constructKeyword) { prefix += 'construct '; }\n            if (m.foreignKeyword) { prefix += 'foreign '; }\n            if (m.staticKeyword) { prefix += 'static '; }\n\n            // get the list of param labels\n            const params = m.parameters ? m.parameters.map((t: any) => t.text) : [];\n            const label = `${prefix}${c.name.text}.${m.name.text}(${params.join(', ')})`; // Class.funcName(param1, param2, param3)\n\n            // use the relative path if possible to save space in the thumbnail\n            let documentation = vscode.workspace.asRelativePath(m.name.source.path);\n            if (m.name.source.path !== 'core') {\n              documentation += ` (line ${m.name.lineStart})`;\n            }\n\n            // setup the signature object \n            const sig = new vscode.SignatureInformation(label, documentation);\n            sig.parameters = params.map((p: any) => new vscode.ParameterInformation(p));\n\n            // we'll use the function name to filter this.signatures when requested\n            if (m.staticKeyword || m.constructKeyword) {\n              if (!this.staticSignatures.has(c.name.text)) {\n                this.staticSignatures.set(c.name.text, []);\n              }\n\n              this.staticSignatures.get(c.name.text)!.push([m.name.text, sig]);\n            } else {\n              this.signatures.push([m.name.text, sig]);\n            }\n\n            // setup the autocomplete for the function itself, icon depending on static or not\n            if (m.staticKeyword || m.constructKeyword) {\n              if (!this.staticCompletions.has(c.name.text)) {\n                this.staticCompletions.set(c.name.text, []);\n              }\n              if (!staticMethodSet.has(m.name.text)) {\n                const item = new vscode.CompletionItem(m.name.text, vscode.CompletionItemKind.Function);\n                item.detail = `${prefix}${c.name.text}.${m.name.text}`;\n                this.staticCompletions.get(c.name.text)!.push(item);\n                staticMethodSet.add(m.name.text);\n              }\n            } else {\n              // this is a instance method\n              if (!methodSet.has(m.name.text)) {\n                const item = new vscode.CompletionItem(m.name.text, vscode.CompletionItemKind.Method);\n                item.detail = `${prefix}${c.name.text}.${m.name.text}`;\n                this.completions.push(item);\n                methodSet.add(m.name.text); // FIXME: probably don't want this once we actually resolve classes right? we may have different functions that vary in foreign/static properties\n              }\n            }\n\n            // grab any variables out of the body recursively\n            // TODO: this seems to be incomplete. timer.wren, it only grabs var f, but not the var t inside the block arg\n            // probably missing other things\n            const className = c.name.text;\n            const visitBody = (m: any) => {\n              // if m.statements is undefined, the iterator will exception out\n              if (!m.statements) {\n                return;\n              }\n\n              for (let s of m.statements) {\n                // look for more potential statements\n                for (let prop of ['body', 'blockArgument', 'thenBranch', 'elseBranch']) {\n                  if (s[prop]) {\n                    visitBody(s[prop]);\n                  }\n                }\n\n                // if it's a \"var a = 1\" grab the name\n                if (s.type === 'VarStmt') {\n                  if (uniqVars.has(s.name.text)) {\n                    continue;\n                  }\n                  uniqVars.add(s.name.text);\n                  const item = new vscode.CompletionItem(s.name.text, vscode.CompletionItemKind.Variable);\n                  item.detail = 'class ' + className;\n                  classVars.push(item);\n                  continue;\n                }\n\n                // there are a few types of assignments, some don't have names\n                if (s.type === 'AssignmentExpr' && s.target.name && (s.target.name.type === 'field' || s.target.name.type === 'staticField')) {\n                  if (uniqVars.has(s.target.name.text)) {\n                    continue;\n                  }\n                  uniqVars.add(s.target.name.text);\n\n                  const item = new vscode.CompletionItem(s.target.name.text, vscode.CompletionItemKind.Field);\n                  item.detail = 'class ' + className;\n                  classVars.push(item);\n                  continue;\n                }\n              }\n            };\n\n            // exception handler since this one has been tricky\n            try {\n              if (m.body) {\n                visitBody(m.body);\n              }\n            } catch (err) {\n              console.error(err);\n            }\n\n          }\n        });\n    }\n  }\n\n  // take a module we've parsed, and recursively parse all the imports\n  updateFileImports(start: Module): void {\n    // find all imports and generate relative paths for them. exclude the built in optionals\n    // since they'll never be found.\n    // TODO: wren module loading has changed recently. rethink this once i've upgraded?\n    const files = start.statements\n      .filter((stmt: any) => stmt.type === 'ImportStmt' && stmt.path.text !== '\"meta\"' && stmt.path.text !== '\"random\"')\n      .map((stmt: any) => {\n        // we get strings with quotes around them, remove them\n        let relPath = stmt.path.text.replace(/\\\"/g, '');\n        // append a ./ and .wren so we can find it on the fs\n        if (relPath.startsWith('./') === false) {\n          relPath = './' + relPath;\n        }\n        if (relPath.endsWith('.wren') === false) {\n          relPath += '.wren';\n        }\n\n        // return the relative path and the folder of the current script\n        return [relPath, path.dirname(stmt.path.source.path)];\n      });\n\n    // loop through every file from an import\n    for (let fileTuple of files) {\n      const file = fileTuple[0];\n\n      let fpath: string = ''; // absolute path of the found file\n      const testPaths = [fileTuple[1], ...this.searchPaths]; // paths to look for file in, first relative, then extra config locations\n      let alreadyParsed = false; // if we're in the middle of, or are already parsing\n      // for each path, look to see if the file is a dupe, otherwise check if the file exists on disk\n      for (let testPath of testPaths) {\n        const joinedPath = path.join(testPath, file);\n        if (this.trees.has(joinedPath) || this.pending.has(joinedPath)) {\n          alreadyParsed = true; // track this separately since it's expected\n          break;\n        }\n\n        // TODO: is the synchronous api bad here? it's probably quick enough.\n        if (fs.existsSync(joinedPath)) {\n          fpath = path.join(testPath, file);\n          break;\n        }\n      }\n\n      // not an error\n      if (alreadyParsed) {\n        continue;\n      }\n\n      // couldn't find the import in any location, warn and move on\n      if (fpath === '') {\n        console.warn(\"couldn't find file in any path \" + file);\n        continue;\n      }\n\n      // we found a file, add it to the list of files we're waiting on\n      this.pending.add(fpath);\n\n      fs.readFile(fpath, (err, data) => {\n        if (err) {\n          console.warn(\"error reading file \" + fpath);\n        } else {\n          this.parseFile(new SourceFile(fpath, data.toString()));\n        }\n\n        // trigger completion update, so we don't update if the last file was an error\n        this.pending.delete(fpath);\n        if (this.pending.size === 0) {\n          console.log(\"Done reading and parsing files, updating completion items\");\n          this.updateCompletionItems();\n        }\n      });\n    }\n\n    // after we've went through the files, and aren't waiting on any files to complete\n    // (aka if a file without any imports happens)\n    if (this.pending.size === 0) {\n      console.log(\"No new imports, updating completion items\");\n      this.updateCompletionItems();\n    }\n  }\n\n  // trigger an update if we don't have the current document\n  updateFileIfNotExists(document: vscode.TextDocument): void {\n    if (this.trees.has(document.fileName)) {\n      return;\n    }\n\n    this.parseDocument(document);\n  }\n\n  // parse the ast, save it, and parse the imports\n  parseFile(source: SourceFile): Module {\n    console.log(`Parsing AST for ${source.path}`);\n\n    const lexer = new Lexer(source);\n    const parser = new Parser(lexer);\n    const ast = parser.parseModule();\n\n    this.trees.set(source.path, ast);\n\n    this.updateFileImports(ast);\n\n    return ast;\n  }\n\n  // create a SourceFile from a vs document and parse it\n  parseDocument(document: vscode.TextDocument): Module {\n    const source = new SourceFile(document.fileName, document.getText());\n    const ast = this.parseFile(source);\n\n    return ast;\n  }\n\n  // used for completion, we'll usually pass a single line into this and mess with tokens\n  lexString(source: string): Token[] {\n    const sf = new SourceFile('string', source);\n    const lexer = new Lexer(sf);\n\n    // generate an array of them instead of using the lexer api\n    let token = lexer.readToken();\n    const tokens: Token[] = [];\n    while (token.type !== Token.eof) {\n      tokens.push(token);\n      token = lexer.readToken();\n    }\n\n    return tokens;\n  }\n\n  // return an object of whatever we need in the extension to try and filter results\n  // and also to provide the argument completion\n  getLineInfo(source: string, position: vscode.Position): any {\n    const tokens = this.lexString(source).reverse();\n\n    // if we find a left parens, we're done parsing arguments\n    let foundLeftParens = false;\n    // used to highlight which param we're on\n    let currParam = 0;\n    // we've found a dot token, will be reset once we find a string.\n    // used to identify ex Draw.rect => ['rect', 'Draw']\n    let foundDot = true;\n    // this is kinda dumb but it's useful for the caller to know if there's been any dot\n    // so we can know if we should show class names, etc\n    let foundAtLeastOneDot = false;\n    const identifiers: object[] = [];\n\n    for (let token of tokens) {\n      // we don't care about anything ahead of us yet\n      if (token.columnStart > position.character) {\n        continue;\n      }\n\n      if (token.type === Token.leftParen) {\n        // don't count anymore params\n        foundLeftParens = true;\n      } else if (!foundLeftParens && token.type === Token.comma) {\n        // we're inside a param list, figure out what param we're on\n        currParam += 1;\n      } else if (token.type === Token.dot) {\n        // reset the identifier finder but note for the return value that there's been one\n        foundDot = true;\n        foundAtLeastOneDot = true;\n      } else if (foundDot && token.type === Token.tname) {\n        // if we've found a dot (or this is the first name token) push it to a list of identifiers\n        // that we've found on this line\n        identifiers.push({\n          text: token.text,\n          isClassName: token.length && token.text[0].toUpperCase() === token.text[0],\n          isField: token.length >= 2 && token.text[0] === '_' && token.text[1] !== '_',\n          isStaticField: token.length >= 2 && token.text[0] === '_' && token.text[1] === '_'\n        });\n        // reset so we need to find another dot first\n        // this might not be necessary?\n        foundDot = false;\n      }\n\n      //console.log(token);\n    }\n    console.log(`foundLeftParens: ${foundLeftParens}, currParam: ${currParam}, foundDot: ${foundDot}, identifiers: ${JSON.stringify(identifiers)}`);\n    return { foundLeftParens, currParam, foundDot: foundAtLeastOneDot, identifiers };\n  }\n}\n\nexport default WrenManager;","'use strict';\n\nimport WrenManager from './wrenmanager';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport * as fs from 'fs';\n\nconst WREN_MODE: vscode.DocumentFilter = { language: 'wren', scheme: 'file' };\n\nconst manager = new WrenManager();\n\n// shows signature parameters\nclass WrenSignatureHelpProvider implements vscode.SignatureHelpProvider {\n  public provideSignatureHelp(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Promise<vscode.SignatureHelp> {\n    const currentLine = document.lineAt(position.line).text;\n\n    return new Promise((resolve, reject) => {\n      manager.updateFileIfNotExists(document);\n\n      const info: any = manager.getLineInfo(currentLine, position);\n\n      const help = new vscode.SignatureHelp();\n      help.activeParameter = info.currParam;\n      help.activeSignature = 0;\n\n      // if it looks like a static method call, only show static signatures\n      if (info.identifiers.length === 2 && info.identifiers[1].isClassName) {\n        if (manager.staticSignatures.has(info.identifiers[1].text)) {\n          help.signatures = manager.staticSignatures.get(info.identifiers[1].text)!\n            .filter((s: any) => s[0] === info.identifiers[0].text)\n            .map((s: any) => s[1]);\n        }\n      } else {\n        // filter out any functions that don't have the same name as whatever's directly to the left of the (\n        help.signatures = manager.signatures.filter((s: any) => s[0] === info.identifiers[0].text).map((s: any) => s[1]);\n      }\n      resolve(help);\n    });\n  }\n\n}\n\n// auto complete symbol names\nclass WrenCompletionItemProvider implements vscode.CompletionItemProvider {\n  public provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): Thenable<vscode.CompletionItem[]> {\n    const currentLine = document.lineAt(position.line).text;\n\n    return new Promise((resolve, reject) => {\n      manager.updateFileIfNotExists(document);\n      const info = manager.getLineInfo(currentLine, position);\n\n      // some really basic filtering rules here just to knock a bunch of useless out.\n      let results: vscode.CompletionItem[] = manager.completions\n        // don't show classes if the line has any dots\n        .filter((c: any) => info.foundDot ? c.kind !== vscode.CompletionItemKind.Class : true)\n        // filter instance methods if the identifier is a class (first letter capitalized)\n        .filter((c: any): boolean => {\n          if (c.kind === vscode.CompletionItemKind.Method) {\n            if (info.identifiers.length === 0) {\n              return true;\n            }\n\n            return info.identifiers[0].isClassName ? false : true;\n          } else {\n            return true;\n          }\n        });\n\n      // add static members if it is a class reference\n      if (info.identifiers.length && info.identifiers[0].isClassName) {\n        if (manager.staticCompletions.has(info.identifiers[0].text)) {\n          const methods = manager.staticCompletions.get(info.identifiers[0].text)!;\n          results = results.concat(methods);\n        }\n      } else {\n        // if we have variables for this file (we usually will) append them\n        if (manager.variables.has(document.fileName)) {\n          const variables = manager.variables.get(document.fileName)!\n            // if there's been at least 1 dot, _field and __staticfields will never be valid\n            .filter((v: any) => info.foundDot ? v.kind !== vscode.CompletionItemKind.Field : true);\n          results = results.concat(variables);\n        }\n      }\n\n      resolve(results);\n    });\n  }\n}\n\nexport function activate(ctx: vscode.ExtensionContext) {\n  console.log('wren-language-provider active!');\n\n  ctx.subscriptions.push(vscode.languages.registerSignatureHelpProvider(WREN_MODE, new WrenSignatureHelpProvider(), '(', ','));\n  ctx.subscriptions.push(vscode.languages.registerCompletionItemProvider(WREN_MODE, new WrenCompletionItemProvider(), '.'));\n  ctx.subscriptions.push(vscode.workspace.onDidSaveTextDocument((doc: vscode.TextDocument) => {\n    // force a full reparse of the file on save\n    if (doc.languageId !== \"wren\") {\n      return;\n    }\n\n    manager.parseDocument(doc);\n  }));\n\n  const config = vscode.workspace.getConfiguration('wren');\n  // additionalModuleDirectories is an array of relative paths to search for wren scripts when reading imports\n  for (let additionalPath of config.additionalModuleDirectories) {\n    if (vscode.workspace.workspaceFolders === undefined) {\n\n    } else {\n      // multi-root workspaces. just add all workspaces that have the additional path\n      for (let ws of vscode.workspace.workspaceFolders) {\n        const scriptPath = path.join(ws.uri.fsPath, additionalPath);\n        if (fs.existsSync(scriptPath)) {\n          manager.addPathToSearch(scriptPath);\n        }\n      }\n    }\n  }\n}\n\nexport function deactivate() {\n}","// this is just a fake class definition typed out from the docs so we can use core modules\nconst coreModules = `\nclass Class {\n  name {}\n  supertype {}\n}\nclass Sound {\n  construct load_ogg(file) {}\n  play() {}\n  play(volume, pitch, pan) {}\n}\nclass Color {\n  static BLACK {}\n  static WHITE {}\n  static RED {}\n  static GREEN {}\n  static BLUE {}\n  r {}\n  g {}\n  b {}\n  a {}\n  toString {}\n  clamp {}\n  construct new(r, g, b, a) {}\n  construct new(r, g, b) {}\n  construct new(rgb) {}\n}\n\nclass Draw {\n    foreign static rectangle(x, y, width, height, r, g, b, a, fill)\n    foreign static circle(x, y, radius, r, g, b, a, fill)\n    foreign static line(x1, y1, x2, y2, r, g, b, a)\n    foreign static put_pixel(x, y, r, g, b)\n    foreign static clear(r, g, b, a)\n    foreign static text(x, y, msg, r, g, b, a)\n    static rectangle(pos, size, color, fill) {}\n    static rectangle(x, y, width, height, color, fill) {}\n    static circle(pos, radius, color, fill) {}\n    static line(start, end, color) {}\n    static put_pixel(pos, color) {}\n    static get_pixel(x, y) {}\n    static get_pixel(pos) {}\n    static clear(r, g, b) {}\n    static clear(color) {}\n    static clear() {}\n    static text(pos, msg, color) {}\n    static text(x, y, msg, color) {}\n}\n\nclass Engine {\n    foreign static init(width, height, title)\n    foreign static destroy()\n    foreign static get_os()\n    static OS_NIX {}\n    static OS_MACOS {}\n    static OS_WINDOWS {}\n    static OS_UNKNOWN {}\n    foreign static get_build_id()\n    foreign static get_build_string()\n}\n\n\nclass FileIO {\n    construct open(path, mode) {}\n    close() {}\n    read_byte() {}\n    write_byte(byte) {}\n    read_char() {}\n    read() {}\n    write(data) {}\n    read_line() {}\n    toString {}\n}\nclass Input {\n    foreign static mouse_x()\n    foreign static mouse_y()\n    static mouse_pos() {}\n    foreign static get_mouse_button()\n    static button_mouse_left {}\n    static button_mouse_right {}\n    static button_mouse_middle {}\n    foreign static get_keycode(key_name)\n    foreign static is_key_pressed(keycode)\n    foreign static is_key_held(keycode)\n}\n\nclass Keycodes {\n    static F1 {}\n    static F2 {}\n    static F3 {}\n    static F4 {}\n    static F5 {}\n    static F6 {}\n    static F7 {}\n    static F8 {}\n    static F9 {}\n    static F10 {}\n    static F11 {}\n    static F12 {}\n    static BACKSPACE {}\n    static TAB {}\n    static RETURN {}\n    static SHIFT {}\n    static CONTROL {}\n    static ALT {}\n    static PAUSE {}\n    static CAPSLOCK {}\n    static ESCAPE {}\n    static SPACE {}\n    static PAGEUP {}\n    static PAGEDOWN {}\n    static END {}\n    static HOME {}\n    static LEFT {}\n    static UP {}\n    static RIGHT {}\n    static DOWN {}\n    static INSERT {}\n    static DELETE {}\n    static NUMLOCK {}\n    static SCROLLLOCK {}\n    static LEFT_SHIFT {}\n    static RIGHT_SHIFT {}\n    static LEFT_CONTROL {}\n    static RIGHT_CONTROL {}\n    static LEFT_ALT {}\n    static RIGHT_ALT {}\n    static SEMICOLON {}\n    static EQUAL {}\n    static COMMA {}\n    static MINUS {}\n    static DOT {}\n    static SLASH {}\n    static BACKTICK {}\n    static LEFT_SQUARE_BRACKET {}\n    static BACKSLASH {}\n    static RIGHT_SQUARE_BRACKET {}\n    static TICK {}\n}\n\nclass Math {\n    static min(a, b) {}\n    static max(a, b) {}\n    static clamp(value, min, max) {}\n    static map(value, old_min, old_max, new_min, new_max) {}\n    static map_clamped(value, old_min, old_max, new_min, new_max) {}\n    static lerp(value, target, factor) {}\n    static abs(a) {}\n    static floor(a) {}\n    static ceil(a) {}\n    static sqrt(a) {}\n    static pow(a, b) {}\n    static sin(a) {}\n    static cos(a) {}\n    static atan2(a, b) {}\n    static fmod(a, b) {}\n    static rad2deg(a) {}\n    static deg2rad(a) {}\n}\n\nclass Random {\n    foreign static seed(seed)\n    foreign static rand()\n    foreign static irange(min, max)\n    foreign static perlin(x, y, z, x_wrap, y_wrap, z_wrap, seed)\n}\n\nclass Surface {\n    foreign static new(width, height)\n    foreign static new_from_png(path)\n    foreign static set_target(surfaceid)\n    foreign static reset_target()\n    foreign static draw(surfaceid, x, y, alpha)\n    static draw_centered(surfaceid, pos, alpha) {}\n    foreign static draw_angle(surfaceid, x, y, angle)\n    static draw_angle(surfaceid, pos, angle) {}\n    foreign static get_width(surfaceid)\n    foreign static get_height(surfaceid)\n    foreign static destroy(surfaceid)\n    foreign static resize(surfaceid, width, height)\n}\nclass Vector {\n    static ZERO {}\n    static UP {}\n    static DOWN {}\n    static LEFT {}\n    static RIGHT {}\n    x { _x }\n    y { _y }\n    x=(value) {}\n    y=(value) {}\n    toString {}\n    construct new(x, y) {}\n    length_squared {}\n    length {}\n    normalized {}\n    angle { (-_y).atan(_x) }\n    distance_to(vec) {}\n    dot(vec) {}\n    distance_to_line(vec1, vec2) {}\n    angle_to(vec) {}\n    rotated(angle) {}\n    clamped(min, max) {}\n}\n\nclass Fiber {\n  static abort(message) {}\n  static current {}\n  construct new(function) {}\n  static suspend() {}\n  static yield() {}\n  static yield(value) {}\n\n  call() {}\n  call(value) {}\n  error {}\n  isDone {}\n  try() {}\n  transfer() {}\n  transfer(value) {}\n  transferError(error) {}\n}\n\nclass Fn {\n  construct new(function) {}\n\n  arity {}\n  call(args) {}\n}\n\nclass List is Sequence {\n  static filled(size, element) {}\n  construct new() {}\n\n  add(item) {}\n  clear() {}\n  count {}\n  insert(index, item) {}\n  removeAt(index) {}\n}\n\nclass Map is Sequence {\n  construct new() {}\n  clear() {}\n  containsKey(key) {}\n  count {}\n  keys {}\n  remove(key) {}\n  values {}\n}\n\nclass Num {\n  static fromString(value) {}\n  static pi {}\n  static largest {}\n  static smallest {}\n\n  abs {}\n  acos {}\n  asin {}\n  atan {}\n  atan(x) {}\n  ceil {}\n  cos {}\n  floor {}\n  isInfinity {}\n  isInteger {}\n  isNan {}\n  log {}\n  pow(power) {}\n  round {}\n  sin {}\n  sqrt {}\n  tan {}\n}\n\nclass Object {\n  static same(obj1, obj2) {}\n}\n\nclass Sequence {\n  all(predicate) {}\n  any(predicate) {}\n  contains(element) {}\n  count {}\n  count(predicate) {}\n  each(function) {}\n  isEmpty {}\n  join(separator) {}\n  join() {}\n  map(transformation) {}\n  reduce(function) {}\n  reduce(seed, function) {}\n  skip(count) {}\n  take(count) {}\n  toList {}\n  where(predicate) {}\n}\n\nclass String {\n  static fromCodePoint(codePoint) {}\n  bytes {}\n  codePoints {}\n  contains(other) {}\n  count {}\n  endsWith(suffix) {}\n  indexOf(search) {}\n  indexOf(search, start) {}\n  replace(old, swap) {}\n  split(separator) {}\n  startsWith(prefix) {}\n  trim() {}\n  trim(chars) {}\n  trimEnd() {}\n  trimEnd(chars) {}\n  trimStart() {}\n  trimStart(chars) {}\n}\n\nclass System {\n  static clock {}\n  static gc() {}\n  static print() {}\n  static print(object) {}\n  static printAll(sequence) {}\n  static write(object) {}\n}\n`;\n\nexport { coreModules };","module.exports = require(\"vscode\");","import Chars from './chars';\nimport Token from './token';\nimport SourceFile from './sourcefile';\n\nconst KEYWORDS: Map<string, string> = new Map([\n  [\"break\", Token.breakKeyword],\n  [\"class\", Token.classKeyword],\n  [\"construct\", Token.constructKeyword],\n  [\"else\", Token.elseKeyword],\n  [\"false\", Token.falseKeyword],\n  [\"for\", Token.forKeyword],\n  [\"foreign\", Token.foreignKeyword],\n  [\"if\", Token.ifKeyword],\n  [\"import\", Token.importKeyword],\n  [\"in\", Token.inKeyword],\n  [\"is\", Token.isKeyword],\n  [\"null\", Token.nullKeyword],\n  [\"return\", Token.returnKeyword],\n  [\"static\", Token.staticKeyword],\n  [\"super\", Token.superKeyword],\n  [\"this\", Token.thisKeyword],\n  [\"true\", Token.trueKeyword],\n  [\"var\", Token.varKeyword],\n  [\"while\", Token.whileKeyword],\n]);\n\n// Data table for tokens that are tokenized using maximal munch.\n//\n// The key is the character that starts the token or tokens. After that is a\n// list of token types and characters. As long as the next character is matched,\n// the type will update to the type after that character.\nconst PUNCTUATORS = {\n  [Chars.leftParen]: [Token.leftParen],\n  [Chars.rightParen]: [Token.rightParen],\n  [Chars.leftBracket]: [Token.leftBracket],\n  [Chars.rightBracket]: [Token.rightBracket],\n  [Chars.leftBrace]: [Token.leftBrace],\n  [Chars.rightBrace]: [Token.rightBrace],\n  [Chars.colon]: [Token.colon],\n  [Chars.comma]: [Token.comma],\n  [Chars.star]: [Token.star],\n  [Chars.slash]: [Token.slash],\n  [Chars.percent]: [Token.percent],\n  [Chars.plus]: [Token.plus],\n  [Chars.minus]: [Token.minus],\n  [Chars.tilde]: [Token.tilde],\n  [Chars.caret]: [Token.caret],\n  [Chars.question]: [Token.question],\n  [Chars.lineFeed]: [Token.line],\n\n  [Chars.pipe]: [Token.pipe, Chars.pipe, Token.pipePipe],\n  [Chars.amp]: [Token.amp, Chars.amp, Token.ampAmp],\n  [Chars.bang]: [Token.bang, Chars.equal, Token.bangEqual],\n  [Chars.equal]: [Token.equal, Chars.equal, Token.equalEqual],\n\n  [Chars.dot]: [Token.dot, Chars.dot, Token.dotDot, Chars.dot, Token.dotDotDot]\n};\n\nclass Lexer {\n  source: SourceFile;\n  start: number;\n  current: number;\n  interpolations: number[];\n\n  constructor(source: SourceFile) {\n    this.source = source;\n    this.start = 0;\n    this.current = 0;\n    this.interpolations = [];\n  }\n\n  public readToken(): Token {\n    if (this.current >= this.source.length) {\n      return this.makeToken(Token.eof);\n    }\n\n    this.skipWhitespace();\n\n    // TODO: Skip comments.\n\n    this.start = this.current;\n    const c = this.source.index(this.current);\n    this.advance();\n\n    if (this.interpolations.length > 0) {\n      const last = this.interpolations.length - 1;\n      if (c === Chars.leftParen) {\n        this.interpolations[last]++;\n      } else if (c === Chars.rightParen) {\n        this.interpolations[last]--;\n\n        // The last \")\" in an interpolated expression ends the expression and resumes the string.\n        if (this.interpolations[last] === 0) {\n          this.interpolations.pop();\n          return this.readString();\n        }\n      }\n    }\n\n    if (c in PUNCTUATORS) {\n      const punctuator = PUNCTUATORS[c];\n      let type = punctuator[0];\n      let i = 1;\n      while (1 < punctuator.length) {\n        if (!this.match(punctuator[i])) {\n          break;\n        }\n\n        type = punctuator[i + 1];\n        i += 2;\n      }\n\n      return this.makeToken(type.toString());\n    }\n\n    // Handle \"<\", \"<<\", and \"<=\".\n    if (c === Chars.less) {\n      if (this.match(Chars.less)) { return this.makeToken(Token.lessLess); }\n      if (this.match(Chars.equal)) { return this.makeToken(Token.lessEqual); }\n      return this.makeToken(Token.less);\n    }\n\n    // Handle \">\", \">>\", and \">=\".\n    if (c === Chars.greater) {\n      if (this.match(Chars.greater)) { return this.makeToken(Token.greaterGreater); }\n      if (this.match(Chars.equal)) { return this.makeToken(Token.greaterEqual); }\n      return this.makeToken(Token.greater);\n    }\n\n    if (c === Chars.underscore) { return this.readField(); }\n    if (c === Chars.quote) { return this.readString(); }\n\n    if (c === Chars.zero && this.peek() === Chars.lowerX) { return this.readHexNumber(); }\n    if (Chars.isDigit(c)) { return this.readNumber(); }\n    if (Chars.isAlpha(c)) { return this.readName(); }\n\n    return this.makeToken(Token.error);  \n  }\n\n  // Skips over whitespace and comments.\n  private skipWhitespace(): void {\n    while (true) {\n      const c = this.peek();\n      if (c === Chars.tab || c === Chars.carriageReturn || c === Chars.space) {\n        // Whitespace is ignored.\n        this.advance();\n      } else if (c === Chars.slash && this.peek(1) === Chars.slash) {\n        // A line comment stops at the newline since newlines are significant.\n        while (this.peek() !== Chars.lineFeed && !this.isAtEnd) {\n          this.advance();\n        }\n      } else if (c === Chars.slash && this.peek(1) === Chars.star) {\n        this.advance();\n        this.advance();\n      } else if (c === Chars.slash && this.peek(1) === Chars.star) {\n        this.advance();\n        this.advance();\n\n        // Block comments can nest.\n        let nesting = 1;\n        while (nesting > 0) {\n          // TODO: Report error.\n          if (this.isAtEnd) {\n            return;\n          }\n\n          if (this.peek() === Chars.slash && this.peek(1) === Chars.star) {\n            this.advance();\n            this.advance();\n            nesting++;\n          } else if (this.peek() === Chars.star && this.peek(1) === Chars.slash) {\n            this.advance();\n            this.advance();\n            nesting--;\n            if (nesting === 0) {\n              break;\n            }\n          } else {\n            this.advance();\n          }\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Reads a static or instance field.\n  private readField(): Token {\n    let type = Token.field;\n    if (this.match(Chars.underscore)) {\n      type = Token.staticField;\n    }\n\n     // Read the rest of the name.\n    while (this.match((c: number) => Chars.isAlphaNumeric(c))) { }\n    return this.makeToken(type);\n  }\n\n  // Reads a string literal.\n  private readString(): Token {\n    let type = Token.string;\n\n    while (this.current < this.source.length - 1) {\n      const c = this.source.index(this.current);\n      this.advance();\n\n      if (c === Chars.backslash) {\n        // TODO: Process specific escapes and validate them.\n        this.advance();\n      } else if (c === Chars.percent) {\n        // Consume the '('.\n        this.advance();\n        // TODO: Handle missing '('.\n        this.interpolations.push(1);\n        type = Token.interpolation;\n        break;\n      } else if (c === Chars.quote) {\n        break;\n      }\n    }\n\n    // TODO: Handle unterminated string.\n    return this.makeToken(type);\n  }\n\n  // Reads a number literal.\n  private readHexNumber(): Token {\n    // Skip past the `x`.\n    this.advance();\n\n    // Read the rest of the number.\n    while (this.match((c: number) => Chars.isHexDigit(c))) { }\n    return this.makeToken(Token.number);\n  }\n\n  // Reads a number literal.\n  private readNumber(): Token {\n    // Read the rest of the number.\n    while (this.match((c: number) => Chars.isDigit(c))) { }\n\n    return this.makeToken(Token.number);\n  }\n\n  // Reads an identifier or keyword token.\n  private readName(): Token {\n    // Read the rest of the name.\n    while (this.match((c: number) => Chars.isAlphaNumeric(c))) { }\n\n    const text = this.source.substring(this.start, this.current - this.start);\n    let type: string = Token.tname;\n    if (KEYWORDS.has(text)) {\n      type = KEYWORDS.get(text)!;\n    }\n\n    return new Token(this.source, type, this.start, this.current - this.start);\n  }\n\n  // Returns `true` if we have scanned all characters.\n  get isAtEnd(): boolean {\n    return this.current >= this.source.length;\n  }\n\n  // Advances past the current character.\n  private advance(): void {\n    this.current++;\n  }\n\n  // Returns the byte value of the current character.\n  private peek(n = 0): number {\n    if (this.current + n >= this.source.length) {\n      return -1;\n    }\n\n    return this.source.index(this.current + n);\n  }\n\n  // Consumes the current character if it matches [condition], which can be a\n  // numeric code point value or a function that takes a code point and returns\n  // `true` if the code point matches.\n  private match(condition: any) {\n    if (this.isAtEnd) {\n      return false;\n    }\n\n    const c = this.source.index(this.current);\n    if (typeof condition === 'function') {\n      if (condition(c) !== true) {\n        return false;\n      }\n    } else if (c !== condition) {\n      return false;\n    }\n\n    this.advance();\n    return true;\n  }\n\n  // Creates a token of [type] from the current character range.\n  public makeToken(type: string): Token {\n    return new Token(this.source, type, this.start, this.current - this.start);\n  }\n}\n\nexport default Lexer;","import Lexer from './lexer';\nimport Token from './token';\n\ninterface Node { type: String; }\n\ninterface Expr extends Node { }\n\ninterface Stmt extends Node { }\n\ninterface Module extends Node {\n  statements: Stmt[];\n}\n\ninterface MapEntry {\n  type: String;\n  key: Expr;\n  value: Expr;\n}\n\ninterface Method {\n  type: String;\n  foreignKeyword?: Token;\n  staticKeyword?: Token;\n  constructKeyword?: Token;\n  name?: Token;\n  body?: Body;\n  parameters: Token[];\n}\n\ninterface Body {\n  type: String;\n  parameters: Token[];\n  expression?: Expr;\n  statements?: Stmt[];\n}\n\ninterface ListExpr extends Expr {\n  leftBracket?: Token;\n  elements: Expr[];\n  rightBracket?: Token;\n}\n\ninterface ThisExpr extends Expr {\n  keyword: Token;\n}\n\ninterface NullExpr extends Expr {\n  value: Token;\n}\n\ninterface StaticFieldExpr extends Expr {\n  name: Token;\n}\n\ninterface FieldExpr extends Expr {\n  name: Token;\n}\n\ninterface CallExpr extends Expr {\n  receiver?: Expr;\n  name: Token;\n  args: Expr[];\n  blockArgument?: Body;\n}\n\ninterface PrefixExpr extends Expr {\n  operator: Token;\n  right: Expr;\n}\n\ninterface GroupingExpr extends Expr {\n  leftParen?: Token;\n  expression: Expr;\n  rightParen?: Token;\n}\n\ninterface AssignmentExpr extends Expr {\n  target: Expr;\n  equal: Token;\n  value: Expr;\n}\n\ninterface InfixExpr extends Expr {\n  left: any;\n  operator: Token;\n  right: any;\n}\n\ninterface MapExpr extends Expr {\n  leftBrace?: Token;\n  entries: MapEntry[];\n  rightBrace?: Token;\n}\n\ninterface ConditionalExpr extends Expr {\n  condition: InfixExpr;\n  question: Token;\n  thenBranch: Expr;\n  colon: Token;\n  elseBranch: Expr;\n}\n\ninterface NumExpr extends Expr {\n  value: Token;\n}\n\ninterface SuperExpr extends Expr {\n  name?: Token;\n  args: Expr[];\n  blockArgument?: Body;\n}\n\ninterface StringExpr extends Expr {\n  value: Token;\n}\n\ninterface SubscriptExpr extends Expr {\n  receiver: Expr;\n  leftBracket: Token;\n  args: Expr[];\n  rightBracket: Token;\n}\n\ninterface BoolExpr extends Expr {\n  value: Token;\n}\n\ninterface InterpolationExpr extends Expr {\n  strings: Token[];\n  expressions: Expr[];\n}\n\ninterface ForStmt extends Stmt {\n  variable: Token;\n  iterator: Expr;\n  body: Stmt;\n}\n\ninterface ReturnStmt extends Stmt {\n  keyword: Token;\n  value: Expr;\n}\n\ninterface BlockStmt extends Stmt {\n  statements: Stmt[];\n}\n\ninterface VarStmt extends Stmt {\n  name: Token;\n  initializer: Stmt;\n}\n\ninterface ImportStmt extends Stmt {\n  path: Token;\n  variables: Token[];\n}\n\ninterface IfStmt extends Stmt {\n  condition: Expr;\n  thenBranch: Stmt;\n  elseBranch: Stmt;\n}\n\ninterface BreakStmt extends Stmt {\n  keyword: Token;\n}\n\ninterface WhileStmt extends Stmt {\n  condition: Expr;\n  body: Stmt;\n}\n\ninterface ClassStmt extends Stmt {\n  foreignKeyword?: Token;\n  name: Token;\n  superclass?: Token;\n  methods: Method[];\n}\n\nconst EQUALITY_OPERATORS = [\n  Token.equalEqual,\n  Token.bangEqual\n];\n\nconst COMPARISON_OPERATORS = [\n  Token.less,\n  Token.lessEqual,\n  Token.greater,\n  Token.greaterEqual\n];\n\nconst BITWISE_SHIFT_OPERATORS = [\n  Token.lessLess,\n  Token.greaterGreater\n];\n\nconst RANGE_OPERATORS = [\n  Token.dotDot,\n  Token.dotDotDot\n];\n\nconst TERM_OPERATORS = [\n  Token.plus,\n  Token.minus\n];\n\nconst FACTOR_OPERATORS = [\n  Token.star,\n  Token.slash,\n  Token.percent\n];\n\nconst PREFIX_OPERATORS = [\n  Token.minus,\n  Token.bang,\n  Token.tilde\n];\n\nconst INFIX_OPERATORS = [\n  Token.pipePipe,\n  Token.ampAmp,\n  Token.equalEqual,\n  Token.bangEqual,\n  Token.isKeyword,\n  Token.less,\n  Token.lessEqual,\n  Token.greater,\n  Token.greaterEqual,\n  Token.pipe,\n  Token.caret,\n  Token.amp,\n  Token.lessLess,\n  Token.greaterGreater,\n  Token.dotDot,\n  Token.dotDotDot,\n  Token.plus,\n  Token.minus,\n  Token.star,\n  Token.slash,\n  Token.percent\n];\n\nclass Parser {\n  lexer: Lexer;\n  current?: Token;\n  previous?: Token;\n  problems: any[];\n\n  constructor(lexer: Lexer) {\n    this.lexer = lexer;\n    this.current = lexer.readToken();\n    this.problems = [];\n  }\n\n  parseModule(): Module {\n    this.ignoreLine();\n\n    const statements: Stmt[] = [];\n    while (this.peek() !== Token.eof) {\n      const def = this.definition();\n      statements.push(def);\n      //console.log(def);\n      if (this.peek() === Token.eof) {\n        break;\n      }\n\n      this.consumeLine(\"Expect newline.\");\n    }\n\n    this.consume(Token.eof, \"Expect end of input.\");\n\n    return { type: 'Module', statements };\n  }\n\n  definition(): Stmt {\n    if (this.match(Token.classKeyword)) {\n      return this.finishClass();\n    }\n\n    if (this.match(Token.foreignKeyword)) {\n      const foreignKeyword = this.previous;\n      this.consume(Token.classKeyword, \"Expect 'class' after 'foreign'.\");\n      return this.finishClass(foreignKeyword);\n    }\n\n    let variables: Token[] = [];\n    if (this.match(Token.importKeyword)) {\n      const path = this.consume(Token.string, \"Expect import path.\");\n\n      // Parse the variable list, if there is one.\n      if (this.match(Token.forKeyword)) {\n        this.ignoreLine();\n\n        variables = [];\n        while (true) {\n          variables.push(this.consume(Token.tname, \"Expect imported variable name.\"));\n          if (!this.match(Token.comma)) {\n            break;\n          }\n\n          this.ignoreLine();\n        }\n      }\n\n      return <ImportStmt>{ type: 'ImportStmt', path, variables };\n    }\n\n    if (this.match(Token.varKeyword)) {\n      const name = this.consume(Token.tname, \"Expect variable name.\");\n      let initializer: Expr | undefined;\n      if (this.match(Token.equal)) {\n        initializer = this.expression();\n      }\n\n      return <VarStmt>{ type: 'VarStmt', name, initializer };\n    }\n\n    return this.statement();\n  }\n\n  // Parses the rest of a class definition after the \"class\" token.\n  finishClass(foreignKeyword?: Token): ClassStmt {\n    const name = this.consume(Token.tname, \"Expect class name.\");\n\n    let superclass: Token | undefined;\n    if (this.match(Token.isKeyword)) {\n      // TODO: This is different from the VM (which is wrong). Need to make\n      // sure we don't parse the class body as a block argument.\n      superclass = this.consume(Token.tname, \"Expect name of superclass.\");\n    }\n\n    const methods: Method[] = [];\n    this.consume(Token.leftBrace, \"Expect '{' after class name.\");\n    this.ignoreLine();\n\n    while (!this.match(Token.rightBrace) && this.peek() !== Token.eof) {\n      methods.push(this.method());\n\n      // Don't require a newline after the last definition.\n      if (this.match(Token.rightBrace)) {\n        break;\n      }\n\n      this.consumeLine(\"Expect newline after definition in class.\");\n    }\n\n    return { type: 'ClassStmt', foreignKeyword, name, superclass, methods };\n  }\n\n  method(): Method {\n    // Note: This parses more permissively than the grammar actually is. For\n    // example, it will allow \"static construct *()\". We'll report errors on\n    // invalid forms later.\n    let foreignKeyword: Token | undefined;\n    if (this.match(Token.foreignKeyword)) {\n      foreignKeyword = this.previous;\n    }\n\n    let staticKeyword: Token | undefined;\n    if (this.match(Token.staticKeyword)) {\n      staticKeyword = this.previous;\n    }\n\n    let constructKeyword: Token | undefined;\n    if (this.match(Token.constructKeyword)) {\n      constructKeyword = this.previous;\n    }\n\n    // TODO: Error on invalid combinations of above keywords.\n\n    let name: Token | undefined;\n    let parameters: Token[] = [];\n    let body: Body | undefined;\n\n    let allowParameters = false;\n\n    if (this.match(Token.leftBracket)) {\n      // Subscript operator.\n      parameters = this.parameterList();\n      this.consume(Token.rightBracket, \"Expect ']' after parameters.\");\n      allowParameters = false;\n    } else if (this.matchAny(INFIX_OPERATORS)) {\n      allowParameters = true;\n    } else if (this.matchAny([Token.bang, Token.tilde])) {\n      allowParameters = false;\n    } else {\n      this.consume(Token.tname, \"Expect method name.\");\n      allowParameters = true;\n    }\n    name = this.previous;\n\n    if (this.match(Token.leftParen)) {\n      // Parse the parameter list even if not allowed to give better errors\n      // and have fewer cascaded errors.\n      if (!allowParameters) {\n        this.error(\"A parameter list is not allowed for this method.\");\n      }\n\n      this.ignoreLine();\n      if (!this.match(Token.rightParen)) {\n        parameters = this.parameterList();\n        this.ignoreLine();\n        this.consume(Token.rightParen, \"Expect ')' after parameters.\");\n      }\n    }\n    // TODO: Setters.\n\n    if (foreignKeyword === undefined) {\n      this.consume(Token.leftBrace, \"Expect '{' before method body.\");\n      body = this.finishBody(parameters);\n    }\n\n    return { type: 'Method', foreignKeyword, staticKeyword, constructKeyword, name, body, parameters };\n  }\n\n  statement(): Stmt {\n    if (this.match(Token.breakKeyword)) {\n      return <BreakStmt>{ type: 'BreakStmt', keyword: this.previous };\n    }\n\n    let elseBranch: Stmt | undefined;\n    if (this.match(Token.ifKeyword)) {\n      this.consume(Token.leftParen, \"Expect '(' after 'if'.\");\n      this.ignoreLine();\n      const condition = this.expression();\n      this.consume(Token.rightParen, \"Expect ')' after if condition.\");\n      const thenBranch = this.statement();\n      if (this.match(Token.elseKeyword)) {\n        elseBranch = this.statement();\n      }\n\n      return <IfStmt>{ type: 'IfStmt', condition, thenBranch, elseBranch };\n    }\n\n    if (this.match(Token.forKeyword)) {\n      this.consume(Token.leftParen, \"Expect '(' after 'for'.\");\n      const variable = this.consume(Token.tname, \"Expect for loop variable name.\");\n      this.consume(Token.inKeyword, \"Expect 'in' after loop variable.\");\n      this.ignoreLine();\n      const iterator = this.expression();\n      this.consume(Token.rightParen, \"Expect ')' after loop expression.\");\n      const body = this.statement();\n      return <ForStmt>{ type: 'ForStmt', variable, iterator, body };\n    }\n\n    if (this.match(Token.whileKeyword)) {\n      this.consume(Token.leftParen, \"Expect '(' after 'while'.\");\n      this.ignoreLine();\n      const condition = this.expression();\n      this.consume(Token.rightParen, \"Expect ')' after while condition.\");\n      const body = this.statement();\n      return <WhileStmt>{ type: 'WhileStmt', condition, body };\n    }\n\n    let value: Expr | undefined;\n    if (this.match(Token.returnKeyword)) {\n      const keyword = this.previous;\n      if (this.peek() !== Token.line) {\n        value = this.expression();\n      }\n\n      return <ReturnStmt>{ type: 'ReturnStmt', keyword, value };\n    }\n\n    if (this.match(Token.leftBrace)) {\n      const statements: Stmt[] = [];\n      this.ignoreLine();\n\n      while (this.peek() !== Token.rightBrace && this.peek() !== Token.eof) {\n        statements.push(this.definition());\n\n        // Don't require a newline after the last statement.\n        if (this.peek() === Token.rightBrace) {\n          break;\n        }\n\n        this.consumeLine(\"Expect newline after statement.\");\n      }\n\n      this.consume(Token.rightBrace, \"Expect '}' after block.\");\n      return <BlockStmt>{ type: 'BlockStmt', statements };\n    }\n\n    return this.expression();\n  }\n\n  // Parses the rest of a method or block argument body.\n  finishBody(parameters: Token[]): Body {\n    // An empty block.\n    if (this.match(Token.rightBrace)) {\n      return { type: 'Body', parameters, expression: undefined, statements: [] };\n    }\n\n    if (!this.matchLine()) {\n      const expr = this.expression();\n      this.ignoreLine();\n      this.consume(Token.rightBrace, \"Expect '}' at end of block.\");\n      return { type: 'Body', parameters, expression: expr, statements: undefined };\n    }\n\n    if (this.match(Token.rightBrace)) {\n      return { type: 'Body', parameters, expression: undefined, statements: [] };\n    }\n\n    const statements: Stmt[] = [];\n    while (this.peek() !== Token.eof) {\n      statements.push(this.definition());\n      this.consumeLine(\"Expect newline after statement.\");\n\n      if (this.match(Token.rightBrace)) {\n        break;\n      }\n    }\n\n    return { type: 'Body', parameters, expression: undefined, statements };\n  }\n\n  expression(): Expr {\n    return this.assignment();\n  }\n\n  // assignment: conditional ( \"=\" assignment )?\n  assignment(): Expr {\n    // TODO: This allows invalid LHS like \"1 + 2 = 3\". Decide if we want to\n    // handle that here or later in the pipeline.\n    const expr = this.conditional();\n    if (!this.match(Token.equal)) {\n      return expr;\n    }\n\n    const equal = this.previous;\n    const value = this.assignment();\n\n    return <AssignmentExpr>{ type: 'AssignmentExpr', target: expr, equal, value };\n  }\n\n  // conditional: logicalOr ( \"?\" conditional \":\" assignment )?\n  conditional(): Expr {\n    const expr = this.logicalOr();\n    if (!this.match(Token.question)) {\n      return expr;\n    }\n\n    const question = this.previous;\n    const thenBranch = this.conditional();\n    const colon = this.consume(Token.colon, \"Expect ':' after then branch of conditional operator.\");\n    const elseBranch = this.assignment();\n\n    return <ConditionalExpr>{ type: 'ConditionalExpr', condition: expr, question, thenBranch, colon, elseBranch };\n  }\n\n  // logicalOr: logicalAnd ( \"||\" logicalAnd )*\n  logicalOr(): InfixExpr { return this.parseInfix([Token.pipePipe], () => this.logicalAnd()); }\n\n  // logicalAnd: equality ( \"&&\" equality )*\n  logicalAnd(): InfixExpr { return this.parseInfix([Token.ampAmp], () => this.equality()); }\n\n  // equality: typeTest ( equalityOperator typeTest )*\n  // equalityOperator: \"==\" | \"!=\"\n  equality(): InfixExpr { return this.parseInfix(EQUALITY_OPERATORS, () => this.typeTest()); }\n\n  // typeTest: comparison ( \"is\" comparison )*\n  typeTest(): InfixExpr { return this.parseInfix([Token.isKeyword], () => this.comparison()); }\n\n  // comparison: bitwiseOr ( comparisonOperator bitwiseOr )*\n  // comparisonOperator: \"<\" | \">\" | \"<=\" | \">=\"\n  comparison(): InfixExpr { return this.parseInfix(COMPARISON_OPERATORS, () => this.bitwiseOr()); }\n\n  // bitwiseOr: bitwiseXor ( \"|\" bitwiseXor )*\n  bitwiseOr(): InfixExpr { return this.parseInfix([Token.pipe], () => this.bitwiseXor()); }\n\n  // bitwiseXor: bitwiseAnd ( \"^\" bitwiseAnd )*\n  bitwiseXor(): InfixExpr { return this.parseInfix([Token.caret], () => this.bitwiseAnd()); }\n\n  // bitwiseAnd: bitwiseShift ( \"&\" bitwiseShift )*\n  bitwiseAnd(): InfixExpr { return this.parseInfix([Token.amp], () => this.bitwiseShift()); }\n\n  // bitwiseShift: range ( bitwiseShiftOperator range )*\n  // bitwiseShiftOperator: \"<<\" | \">>\"\n  bitwiseShift(): InfixExpr { return this.parseInfix(BITWISE_SHIFT_OPERATORS, () => this.range()); }\n\n  // range: term ( rangeOperator term )*\n  // rangeOperator: \"..\" | \"..\"\n  range(): InfixExpr { return this.parseInfix(RANGE_OPERATORS, () => this.term()); }\n\n  // term: factor ( termOperator factor )*\n  // termOperator: \"+\" | \"-\"\n  term(): InfixExpr { return this.parseInfix(TERM_OPERATORS, () => this.factor()); }\n\n  // factor: prefix ( factorOperator prefix )*\n  // factorOperator: \"*\" | \"/\" | \"%\"\n  factor(): InfixExpr { return this.parseInfix(FACTOR_OPERATORS, () => this.prefix()); }\n\n  // prefix: (\"-\" | \"!\" | \"~\")* call\n  prefix(): Expr {\n    if (this.matchAny(PREFIX_OPERATORS)) {\n      return <PrefixExpr>{ type: 'PrefixExpr', operator: this.previous, right: this.prefix() };\n    }\n\n    return this.call();\n  }\n\n  // call: primary ( subscript | \".\" methodCall )*\n  // subscript: \"[\" argumentList \"]\"\n  call(): Expr {\n    let expr = this.primary();\n\n    while (true) {\n      if (this.match(Token.leftBracket)) {\n        const leftBracket = this.previous;\n        const args = this.argumentList();\n        const rightBracket = this.consume(Token.rightBracket, \"Expect ']' after subscript arguments.\");\n        expr = <SubscriptExpr>{ type:'SubscriptExpr', receiver: expr, leftBracket, args, rightBracket };\n      } else if (this.match(Token.dot)) {\n        const name = this.consume(Token.tname, \"Expect method name after '.'.\");\n        expr = this.methodCall(expr, name);\n      } else {\n        break;\n      }\n    }\n\n    return expr;\n  }\n\n  // Parses the argument list for a method call and creates a call expression\n  // for it.\n  //\n  // methodCall: ( \"(\" argumentList? \")\" )? blockArgument?\n  // blockArgument: \"{\" ( \"|\" parameterList \"|\" )? body \"}\"\n  // parameterList: Name ( \",\" Name )*\n  // body:\n  //   | \"\\n\" ( definition \"\\n\" )*\n  //   | expression\n  methodCall(receiver: Expr | undefined, name: Token): CallExpr {\n    var args = this.finishCall();\n    return { type: 'CallExpr', receiver, name, args: args[0], blockArgument: args[1] };\n  }\n\n  // Parses the argument list for a method call. Returns a list containing the\n  // argument list (if any) and block argument (if any). If either is missing,\n  // the list element at that position is `null`.\n  finishCall(): [Expr[], Body | undefined] {\n    let args: Expr[] = [];\n    let blockArgument: Body | undefined;\n\n    if (this.match(Token.leftParen)) {\n      // Allow an empty argument list. Note that we treat this differently than\n      // a getter (no argument list). The former will have a `null` argument\n      // list and the latter will have an empty one.\n      if (this.match(Token.rightParen)) {\n        args = [];\n      } else {\n        args = this.argumentList();\n        this.consume(Token.rightParen, \"Expect ')' after arguments.\");\n      }\n    }\n\n    let parameters: Token[] = [];\n    if (this.match(Token.leftBrace)) {\n      if (this.match(Token.pipe)) {\n        parameters = this.parameterList();\n        this.consume(Token.pipe, \"Expect '|' after block parameters.\");\n      }\n\n      blockArgument = this.finishBody(parameters);\n    }\n\n    return [args, blockArgument];\n  }\n\n  // argumentList: expression ( \",\" expression )*\n  argumentList(): Expr[] {\n    let args: Expr[] = [];\n\n    this.ignoreLine();\n    while (true) {\n      args.push(this.expression());\n      if (!this.match(Token.comma)) {\n        break;\n      }\n\n      this.ignoreLine();\n    }\n\n    return args;\n  }\n\n  // parameterList: name ( \",\" name )*\n  parameterList(): Token[] {\n    let parameters: Token[] = [];\n\n    while (true) {\n      parameters.push(this.consume(Token.tname, \"Expect parameter name.\"));\n      if (!this.match(Token.comma)) {\n        break;\n      }\n\n      this.ignoreLine();\n    }\n\n    return parameters;\n  }\n\n  // primary:\n  //   | grouping\n  //   | listLiteral\n  //   | mapLiteral\n  //   | \"true\" | \"false\" | \"null\" | \"this\"\n  //   | Field | StaticField | Number\n  primary(): Expr {\n    if (this.match(Token.leftParen)) { return this.grouping(); }\n    if (this.match(Token.leftBracket)) { return this.listLiteral(); }\n    if (this.match(Token.leftBrace)) { return this.mapLiteral(); }\n    if (this.match(Token.tname)) { return this.methodCall(undefined, this.previous!); }\n    if (this.match(Token.superKeyword)) { return this.superCall(); }\n\n    if (this.match(Token.falseKeyword)) { return <BoolExpr>{ type: 'BoolExpr', value: this.previous }; }\n    if (this.match(Token.trueKeyword)) { return <BoolExpr>{ type: 'BoolExpr', value: this.previous }; }\n    if (this.match(Token.nullKeyword)) { return <NullExpr>{ type: 'NullExpr', value: this.previous }; }\n    if (this.match(Token.thisKeyword)) { return <ThisExpr>{ type: 'ThisExpr', keyword: this.previous }; }\n\n    // TODO: Error if not inside class.\n    if (this.match(Token.field)) { return <FieldExpr>{ type: 'FieldExpr', name: this.previous }; }\n    if (this.match(Token.staticField)) { return <StaticFieldExpr>{ type: 'StaticFieldExpr', name: this.previous }; }\n\n    if (this.match(Token.number)) { return <NumExpr>{ type: 'NumExpr', value: this.previous }; }\n    if (this.match(Token.string)) { return <StringExpr>{ type: 'StringExpr', value: this.previous }; }\n\n    if (this.peek() === Token.interpolation) { return this.stringInterpolation(); }\n    // TODO: Token.super.\n\n    this.error(\"Expect expression.\");\n    // Make a fake node so that we don't have to worry about null later.\n    // TODO: Should this be an error node?\n    return <NullExpr>{ value: this.previous };\n  }\n\n  // Finishes parsing a parenthesized expression.\n  //\n  // grouping: \"(\" expressions \")\"\n  grouping(): GroupingExpr {\n    const leftParen = this.previous;\n    const expression = this.expression();\n    const rightParen = this.consume(Token.rightParen, \"Expect ')' after expression.\");\n    return { type:'GroupingExpr', leftParen, expression, rightParen };\n  }\n\n  // Finishes parsing a list literal.\n  //\n  // listLiteral: \"[\" ( expression (\",\" expression)* \",\"? )? \"]\"\n  listLiteral(): ListExpr {\n    const leftBracket = this.previous;\n    const elements: Expr[] = [];\n\n    this.ignoreLine();\n\n    while (this.peek() !== Token.rightBracket) {\n      elements.push(this.expression());\n\n      this.ignoreLine();\n      if (!this.match(Token.comma)) {\n        break;\n      }\n      this.ignoreLine();\n    }\n\n    var rightBracket = this.consume(Token.rightBracket, \"Expect ']' after list elements.\");\n    return { type:'ListExpr', leftBracket, elements, rightBracket };\n  }\n\n  // Finishes parsing a map literal.\n  //\n  // mapLiteral: \"[\" ( mapEntry (\",\" mapEntry)* \",\"? )? \"}\"\n  // mapEntry:   expression \":\" expression\n  mapLiteral(): MapExpr {\n    const leftBrace = this.previous;\n    const entries: MapEntry[] = [];\n\n    this.ignoreLine();\n\n    while (this.peek() !== Token.rightBrace) {\n      const key = this.expression();\n      this.consume(Token.colon, \"Expect ':' after map key.\");\n\n      const value = this.expression();\n      entries.push({ type:'MapEntry', key, value });\n\n      this.ignoreLine();\n      if (!this.match(Token.comma)) {\n        break;\n      }\n      this.ignoreLine();\n    }\n\n    const rightBrace = this.consume(Token.rightBrace, \"Expect '}' after map entries.\");\n    return { type:'MapExpr', leftBrace, entries, rightBrace };\n  }\n\n  superCall(): SuperExpr {\n    let name: Token | undefined;\n\n    if (this.match(Token.dot)) {\n      // It's a named super call.\n      name = this.consume(Token.tname, \"Expect method name after 'super.'.\");\n    }\n\n    const args = this.finishCall();\n    return { type:'SuperExpr', name, args: args[0], blockArgument: args[1] };\n  }\n\n  // stringInterpolation: (interpolation expression )? string\n  stringInterpolation(): InterpolationExpr {\n    let strings: Token[] = [];\n    let expressions: Expr[] = [];\n\n    while (this.match(Token.interpolation)) {\n      strings.push(this.previous!);\n      expressions.push(this.expression());\n    }\n\n    // This error should never be reported. It's the lexer's job to ensure we\n    // generate the right token sequence.\n    strings.push(this.consume(Token.string, \"Expect end of string interpolation.\"));\n\n    return { type:'InterpolationExpr', strings, expressions };\n  }\n\n  // Utility methods.\n\n  // Parses a left-associative series of infix operator expressions using any\n  // of [tokenTypes] as operators and calling [parseOperand] to parse the left\n  // and right operands.\n  parseInfix(tokenTypes: string[], parseOperand: Function): InfixExpr {\n    let expr = parseOperand();\n    while (this.matchAny(tokenTypes)) {\n      var operator = this.previous;\n      this.ignoreLine();\n      var right = parseOperand();\n      expr = { type:'InfixExpr', left: expr, operator, right };\n    }\n\n    return expr;\n  }\n\n  // If the next token has [type], consumes and returns it. Otherwise, returns\n  // `null`.\n  match(type: string) {\n    if (this.peek() !== type) {\n      return null;\n    }\n\n    return this.consumeNext();\n  }\n\n  // Consumes and returns the next token if its type is contained in the list\n  // [types].\n  matchAny(types: string[]) {\n    for (let type of types) {\n      var result = this.match(type);\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  // Consumes zero or more newlines. Returns `true` if at least one was matched.\n  matchLine(): boolean {\n    if (!this.match(Token.line)) {\n      return false;\n    }\n\n    while (this.match(Token.line)) { }\n    return true;\n  }\n\n  // Same as [matchLine()], but makes it clear that the intent is to discard newlines appearing where this is called.\n  ignoreLine() {\n    this.matchLine();\n  }\n\n  // Consumes one or more newlines.\n  consumeLine(error: string) {\n    this.consume(Token.line, error);\n    this.ignoreLine();\n  }\n\n  // Reads and consumes the next token.\n  consumeNext(): Token {\n    this.peek();\n    this.previous = this.current;\n    this.current = undefined;\n    return this.previous!;\n  }\n\n  // Reads the next token if it is of [type]. Otherwise, discards it and\n  // reports an error with [message]\n  consume(type: string, message: string): Token {\n    const token = this.consumeNext();\n    if (token.type !== type) {\n      this.error(message);\n    }\n\n    return token;\n  }\n\n  // Returns the type of the next token.\n  peek(): string {\n    if (this.current === undefined) { this.current = this.lexer.readToken(); }\n    return this.current.type!;\n  }\n\n  error(message: string): void {\n    this.problems.push([message, [this.current !== undefined ? this.current : this.previous]]);\n  }\n}\n\nexport default Parser;\nexport { Module, ImportStmt };","// Utilities for working with characters.\nclass Chars {\n  static tab = 0x09;\n  static lineFeed = 0x0a;\n  static carriageReturn = 0x0d;\n  static space = 0x20;\n  static bang = 0x21;\n  static quote = 0x22;\n  static percent = 0x25;\n  static amp = 0x26;\n  static leftParen = 0x28;\n  static rightParen = 0x29;\n  static star = 0x2a;\n  static plus = 0x2b;\n  static comma = 0x2c;\n  static minus = 0x2d;\n  static dot = 0x2e;\n  static slash = 0x2f;\n\n  static zero = 0x30;\n  static nine = 0x39;\n\n  static colon = 0x3a;\n  static less = 0x3c;\n  static equal = 0x3d;\n  static greater = 0x3e;\n  static question = 0x3f;\n\n  static upperA = 0x41;\n  static upperF = 0x46;\n  static upperZ = 0x5a;\n\n  static leftBracket = 0x5b;\n  static backslash = 0x5c;\n  static rightBracket = 0x5d;\n  static caret = 0x5e;\n  static underscore = 0x5f;\n\n  static lowerA = 0x61;\n  static lowerF = 0x66;\n  static lowerX = 0x78;\n  static lowerZ = 0x7a;\n\n  static leftBrace = 0x7b;\n  static pipe = 0x7c;\n  static rightBrace = 0x7d;\n  static tilde = 0x7e;\n\n  static isAlpha(c: number): boolean {\n    return (c >= Chars.lowerA && c <= Chars.lowerZ) ||\n      (c >= Chars.upperA && c <= Chars.upperZ) ||\n      c === Chars.underscore;\n  }\n\n  static isDigit(c: number): boolean { return c >= Chars.zero && c <= Chars.nine; }\n\n  static isAlphaNumeric(c: number): boolean { return Chars.isAlpha(c) || Chars.isDigit(c); }\n\n  static isHexDigit(c: number): boolean {\n    return c >= Chars.zero && c <= Chars.nine ||\n      c >= Chars.lowerA && c <= Chars.lowerF ||\n      c >= Chars.upperA && c <= Chars.upperF;\n  }\n\n  static isLowerAlpha(c: number): boolean { return c >= Chars.lowerA && c <= Chars.lowerZ; }\n}\n\nexport default Chars;","module.exports = require(\"fs\");","import Chars from './chars';\n\nclass SourceFile {\n  public path: string;\n  private string: any;\n  private lines: number[];\n\n  constructor(path: string, string: string) {\n    this.path = path;\n    this.string = string;\n\n    this.lines = [0];\n    for (let i = 0; i < string.length; i++) {\n      if (this.string.charCodeAt(i) === Chars.lineFeed) {\n        this.lines.push(i + 1);\n      }\n    }\n  }\n\n  // Gets the byte at i in the source file.\n  public index(i: number): number { return this.string.charCodeAt(i); }\n\n  // The number of bytes in the source file.\n  get length(): number { return this.string.length; }\n\n  // Gets the 1-based line that the byte at offset lies on.\n  public columnAt(offset: number): number {\n    let column = 1;\n\n    // Walk backwards until we hit a newline\n    for (let i = offset - 1; i > 0; i--) {\n      if (this.string.charCodeAt(i) === Chars.lineFeed) {\n        break;\n      }\n      column += 1;\n    }\n    return column;\n  }\n\n  // Gets the 1-based line that the byte at offset lies on.\n  public lineAt(offset: number): number {\n    for (let i = 0; i < this.lines.length; i++) {\n      if (offset < this.lines[i]) {\n        return i;\n      }\n    }\n    return this.lines.length;\n  }\n\n  // Gets the source text of [line], where 1 is the first line.\n  public getLine(line: number): string {\n    return this.string.substring(this.lines[line - 1], this.lines[line] - 1);\n  }\n\n  // Gets a substring of the source string starting at [start] with [length] bytes\n  public substring(start: number, length: number): string {\n    return this.string.substr(start, length);\n  }\n}\n\nexport default SourceFile;","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["static","source","type","start","length","constructor","this","text","substring","lineStart","lineAt","lineEnd","columnStart","columnAt","columnEnd","toString","trees","Map","variables","searchPaths","pending","Set","completions","staticCompletions","signatures","staticSignatures","sourceFile","coreModules","parseFile","addPathToSearch","p","push","updateCompletionItems","console","info","methodSet","classSet","e","entries","path","module","classVars","set","uniqVars","statements","filter","o","forEach","c","staticMethodSet","has","name","item","vscode","CompletionItem","CompletionItemKind","Class","detail","workspace","asRelativePath","add","m","methods","prefix","constructKeyword","foreignKeyword","staticKeyword","params","parameters","map","t","label","join","documentation","sig","SignatureInformation","ParameterInformation","get","Function","Method","className","visitBody","s","prop","target","Field","Variable","body","err","error","updateFileImports","files","stmt","relPath","replace","startsWith","endsWith","dirname","fileTuple","file","fpath","testPaths","alreadyParsed","testPath","joinedPath","fs","existsSync","readFile","data","warn","delete","size","log","updateFileIfNotExists","document","fileName","parseDocument","lexer","ast","parseModule","getText","lexString","sf","token","readToken","tokens","eof","getLineInfo","position","reverse","foundLeftParens","currParam","foundDot","foundAtLeastOneDot","identifiers","character","leftParen","comma","dot","tname","isClassName","toUpperCase","isField","isStaticField","JSON","stringify","ctx","subscriptions","languages","registerSignatureHelpProvider","WREN_MODE","WrenSignatureHelpProvider","registerCompletionItemProvider","WrenCompletionItemProvider","onDidSaveTextDocument","doc","languageId","manager","config","getConfiguration","additionalPath","additionalModuleDirectories","undefined","workspaceFolders","ws","scriptPath","uri","fsPath","language","scheme","provideSignatureHelp","currentLine","line","Promise","resolve","reject","help","SignatureHelp","activeParameter","activeSignature","provideCompletionItems","results","kind","concat","v","exports","require","KEYWORDS","breakKeyword","classKeyword","elseKeyword","falseKeyword","forKeyword","ifKeyword","importKeyword","inKeyword","isKeyword","nullKeyword","returnKeyword","superKeyword","thisKeyword","trueKeyword","varKeyword","whileKeyword","PUNCTUATORS","rightParen","leftBracket","rightBracket","leftBrace","rightBrace","colon","star","slash","percent","plus","minus","tilde","caret","question","lineFeed","pipe","pipePipe","amp","ampAmp","bang","equal","bangEqual","equalEqual","dotDot","dotDotDot","current","interpolations","makeToken","skipWhitespace","index","advance","last","pop","readString","punctuator","i","match","less","lessLess","lessEqual","greater","greaterGreater","greaterEqual","underscore","readField","quote","zero","peek","lowerX","readHexNumber","isDigit","readNumber","isAlpha","readName","tab","carriageReturn","space","isAtEnd","nesting","field","staticField","isAlphaNumeric","string","backslash","interpolation","isHexDigit","number","n","condition","EQUALITY_OPERATORS","COMPARISON_OPERATORS","BITWISE_SHIFT_OPERATORS","RANGE_OPERATORS","TERM_OPERATORS","FACTOR_OPERATORS","PREFIX_OPERATORS","INFIX_OPERATORS","previous","problems","ignoreLine","def","definition","consumeLine","consume","finishClass","initializer","expression","statement","superclass","method","allowParameters","parameterList","matchAny","finishBody","keyword","elseBranch","value","thenBranch","variable","iterator","matchLine","expr","assignment","conditional","logicalOr","parseInfix","logicalAnd","equality","typeTest","comparison","bitwiseOr","bitwiseXor","bitwiseAnd","bitwiseShift","range","term","factor","operator","right","call","primary","receiver","args","argumentList","methodCall","finishCall","blockArgument","grouping","listLiteral","mapLiteral","superCall","stringInterpolation","elements","key","strings","expressions","tokenTypes","parseOperand","left","consumeNext","types","result","message","Chars","lowerA","lowerZ","upperA","upperZ","nine","lowerF","upperF","isLowerAlpha","lines","charCodeAt","offset","column","getLine","substr","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}